# レジスタについて

## Register
CPUに内蔵された記憶領域(CPUのレジスタ=値を登録しておく記憶領域)
- メインメモリとの類似点
  - 値を記憶しておくという点では、メインメモリと同様
- メインメモリとの相違点
  - メインメモリはCPUの外側にあるという点

### RIP Reigister
- debug時によく使うRegister
  - 実行される予定の機械語命令の位置を示す

```bash
# メインメモリの中で指定したアドレス付近の値をメモリダンプ
# x /fmt addr
x /4xb 0x067ae4c4
x /2i 0x067ae4c4
```

### 詳細
汎用レジスタと特殊レジスタが搭載されている

#### 汎用レジスタ
- 主な目的: 値を記憶する
  - メインメモリと役割は似ているが、容量と読み書きの速度が異なる
    - 容量
      - 例: メインメモリが16GB(2**34byte)程度あるのに対し、x86-64アーキテクチャの汎用レジストリは128B(2**7byte)
    - 速度(レジスタは容量が小さく読み書きが速い)
      - 例: メインメモリ(DDR4-SDRAM)は読み書きに約100nsに対し、レジスタは待ち時間なく読み書き可能
        2GHzで動くCPUであれば0.5ns程度

- x86-64アーキテクチャの汎用レジスタは次の16個で、CPUの演算対象に指定できる
  - RAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP, R8 ~ R15
    - 例えば、加算命令addには次のように2つのレジスタを指定可能
    ```bash
    add rax, rbx
    ; オペコード オペランド1, オペランド2
    ; RAXにRBXの値を加えるという意味
    ```

- x86-64の汎用レジスタは全て8byte(=64bit)
  - しかし、場合によってそれより小さいレジスタが欲しいケースがある
    - 例: C++で`char`, `uint16_t`といった8バイトより小さい型を扱う場合
    - 小さい型の変数(変数はメインメモリに配置される)をレジスタに読み出したり、演算したり、結果をメモリに書き戻したりする
    - そのために、汎用レジスタの一部を小さなレジスタとしてアクセスできるようになっている
      - AXレジスタはRAXレジスタの下位16ビットを表す名前になっていて、AXを読み書きすることでRAXの下位16ビットを読み書きできる
- 一般に、x86-64の演算命令は2つのオペランド(引数)を取り、`オペランド1`が書き込み先、`オペランド2`が読み込み元となる

##### RAX型 (同じパターンのレジスタ=RAX, RBX, RCX, RDX)

63                32 31         16 15   8 7     0
-------------------------------------------------
|                   |             |  AH  |  AL  |
-------------------------------------------------
                                  |_____ AX ____|
                    |____________ EAX __________|
|___________________ RAX _______________________|

##### RBP型 (同じパターンのレジスタ=RBP, RSP, RSI, RDI)
63                32 31         16 15   8 7     0
-------------------------------------------------
|                   |             |      | BPL  |
-------------------------------------------------
                                  |_____ BP ____|
                    |____________ EBP __________|
|___________________ RBP _______________________|

##### R8型 (同じパターンのレジスタ=R8 ~ R15)
63                32 31         16 15   8 7     0
-------------------------------------------------
|                   |             |      | R8B  |
-------------------------------------------------
                                  |_____ R8W ___|
                    |____________ R8D __________|
|____________________ R8 _______________________|



#### 特殊レジスタ
- 特殊レジスタは汎用レジスタに比べて、多くの種類がある
- 値を記憶する機能
- 値を読み書きするという操作自体に意味があったり、各ビットの役割が異なる場合がある
  - 代表例
    - RIP: CPUが次に実行する命令のメモリアドレスを保持するレジスタ
    - RFLAGS: 命令の実行結果によって変化するフラグを集めたレジスタ
    - CR0: CPUの重要な設定を集めたレジスタ

## Kernelについて
BootLoaderとOS本体(Kernel)の開発方法はいろいろ考えられるが、今回は以下のようにする

- BootLoaderはEEFIアプリとして開発
- KernelはELFバイナリとして開発
- 実行時: BootLoaderからKernelを呼び出す形式

## Execution Steps

### Compile kernel resources

```bash
cd $OS_FROM_SCRATCH/workspace/oscode/kernel/main.cpp
clang++ -O2 -Wall -g --target=x86_64-elf -ffreestanding -mno-red-zone \
  -fno-exceptions -fno-rtti  -std=c++17 -c main.cpp
```
| option              | description                        |
|---------------------|------------------------------------|
| -O2                 | レベル2の最適化を行う                        |
| -Wall               | 警告を出力                              |
| -g                  | でバック情報付きでコンパイル                     |
| --target=x86_64-elf | x86_64向けの機械語を生成する.出力ファイルの形式をELFとする |
| -ffreestanding      | フリースタンディング環境向けにコンパイル               |
| -mno-red-zone       | Red Zone機能を無効にする                   |
| -fno-exceptions     | C++の例外機能を使わない                      |
| -fno-rtti           | C++の動的型情報を使わない                     |
| -std=c++17          | C++ version 17を指定                  |
| -c                  | コンパイルのみ、リンクはしない                    |

```bash
ld.lld --entry KernelMain -z norelro --image-base 0x100000 --static \
  -o kernel.elf main.o
```
| option                | description                |
|-----------------------|----------------------------|
| --entry KernelMain    | KernelMain()をエントリポイントとする   |
| -z norelro            | リロケーション情報を読み込み専用にする機能を使わない |
| --image-base 0x100000 | 出力されたバイナリのベースアドレスを0x100000 |
| -o kernel.elf         | 出力ファイル名をkernel.elfとする      |
| --static              | 静的リンクを行う                   |

### Build Image and Run created OS
```bash
cd $OS_FROM_SCRATCH/edk2
build
$OS_FROM_SCRATCH/osbook/devenv/run_qemu.sh Build/MikanLoaderX64/DEBUG_CLANGPDB/X64/Loader.efi $OS_FROM_SCRATCH/workspace/oscode/kernel/kernl.elf
```

- 起動すると、カーネルの動作が永久ループで止まり、最終の `Print(L"All done\n")`が実行されない
- 確認方法
  1. `info registers`コマンドにて`RIP`の値を確認
    - 何度か実行し、値が変わっていなければ永久ループしている
  2. `RIP`の値付近のメインメモリ内容を確認
    - 

### How to check Register & Main memory
```bash
# step1
info registers
# output: RIP=000000003fb73016 RFL=00000046 [---Z-P-] CPL=0 II=0 A20=1 SMM=0 HLT=0

# step2
x /2i 0x101010
```
References: http://ylb.jp/Tech/x86_64ASM/x86_64_onMac.html


